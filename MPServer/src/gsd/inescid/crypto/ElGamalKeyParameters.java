package gsd.inescid.crypto;

import java.math.BigInteger;
import java.security.GeneralSecurityException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidParameterException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Random;

/**
 * Immutable class ElGamalKeyParameters
 * This class implements the ElGamal parameters generation based on the 
 * DSA key generation algorithms defined in FIPS_186-3, 
 * algorithms A.1.1.2 (for p and q) and A.2.3 (for the generator))
 * 
 * @author Rui Joaquim
 *
 */
public class ElGamalKeyParameters {

	public static final int MINIMUM_KEY_SIZE = 5;
	public static final int TO_STRING_RADIX = 16;
	public static final String DEFAULT_HASH_FUNCTION = "SHA-256";
	
	public static final BigInteger TWO = new BigInteger("2"); //public because it is not available in the BigInteger class
	protected static final BigInteger ONE = BigInteger.ONE;
	protected static final BigInteger ZERO = BigInteger.ZERO;
	
	/** a prime that defines the "encryption group" Z*_p, such that p = 2kq + 1 */
	public final BigInteger p; 
	/** base prime number */
	public final BigInteger q;
	/** generator of G_q, a q-order subgroup of Z*_p that defines the message space */
	public final BigInteger g; 
	
	/**
	 * The generator index following the 
	 * generator creation algorithm A2.3 of FIPS_186-3.
	 */
	public final int GENERATOR_INDEX;
	
	/** As defined in algorithm A.1.1.2 of FIPS_186-3.
	 *  The value is null if the key parameters were not 
	 *  generated by this instance of ElGamalKeyParameters. */
	public final byte[] DOMAIN_PARAMETER_SEED;
	
	/** As defined in algorithm A.1.1.2 of FIPS_186-3.
	 *  The value is -1 if the key parameters were not 
	 *  generated by this instance of ElGamalKeyParameters. */
	public final long COUNTER;
	
	/**
	 * The hash function used in the creation of the key parameters.
	 */
	public final String KEY_PARAMETERS_HASH_FUNCTION;
	
		
	
	/**
	 * Class created to temporary contain the results of the key parameters generation process
	 */
	private final class KeyGenerationParameters{
		BigInteger p;
		BigInteger q;
		byte[] domain_parameter_seed;
		long counter;
		
		KeyGenerationParameters(BigInteger p, BigInteger q, byte[] seed, long counter)
		{
			this.p = p;
			this.q = q;
			this.domain_parameter_seed = seed;
			this.counter = counter;
		}
	}
	
	/**
	 * Create partially validated key parameters from the given parameters.
	 * As no generation information is available the generation constants are 
	 * defined as follows:
	 * 
	 * DOMAIN_PARAMETER_SEED = null;
	 * COUNTER = -1;
	 * GENERATOR_INDEX = -1;
	 * KEY_PARAMETERS_HASH_FUNCTION = null;
	 * 
	 * @param p prime p = 2kq + 1
	 * @param q prime number q which defines the order of the generator g
	 * @param g generator of a q-order subgroup of Z*_p (only partially validated, cf. A.2.2 of FIPS_186-3)
	 * @throws InvalidParameterException if parameters are invalid
	 */
	public ElGamalKeyParameters(BigInteger p, BigInteger q, BigInteger g)
	{	
		// (p-1) mod 2q = 0 ? => p = 2kq + 1
		if (!((p.subtract(ONE)).mod(TWO.multiply(q))).equals(ZERO))
				throw new InvalidParameterException("p != 2*k*q + 1");
		
		if (!p.isProbablePrime(128)) throw new InvalidParameterException("p is not prime");
		if (!q.isProbablePrime(128)) throw new InvalidParameterException("q is not prime");
	
			
		//verify if g is a q-order subgroup generator of Z*_p as defined in A.2.2 of FIPS_186-3
		if(g.compareTo(TWO) < 0 || g.compareTo(p) >= 0 ||
				!(g.modPow(q, p).equals(ONE)) )
			throw new InvalidParameterException("g is not a q-order generator of Z*_p");
	
		this.p = p;
		this.q = q;
		this.g = g;
		this.DOMAIN_PARAMETER_SEED = null;
		this.COUNTER = -1;
		this.GENERATOR_INDEX = -1;
		this.KEY_PARAMETERS_HASH_FUNCTION = null;
	}
	

	
	/**
	 * Create key parameters for the requested key size.
	 * The key parameter are created following algorithm A.1.1.2 of FIPS_186-3 
	 * (the list of acceptable sizes is not verified).
	 * The generator is created following algorithm A2.3 of FIPS_186-3 using 
	 * the first available index.
	 * 
	 * @param modulusSize defines the length of p
	 * @param keySize maximum supported key size in bits (defines the length of q) 
	 * @param random randomness source. If null an instance of the default SecureRandom is used.
	 * @param hashFunction the hash function to use in the key generation process. 
	 * 			   If null the default hash function (SHA-256) will be used. 
	 * @throws GeneralSecurityException if no generator could be created.
	 * @throws InvalidParameterException if keySize < MINIMUM_KEY_SIZE or modulusSize <= keySize.
	 * @throws NoSuchAlgorithmException if there is no provider for the selected hashFunction
	 */
	public ElGamalKeyParameters(int modulusSize, int keySize, Random r, String hashFunction) throws GeneralSecurityException
	{
		if (keySize < MINIMUM_KEY_SIZE) throw new InvalidParameterException("keySize must be >= MINIMUM_KEY_SIZE");
		if (modulusSize <= keySize) throw new InvalidParameterException("modulusSize must be > key_size");
		
		if (r == null)
			r = new SecureRandom();
		
		MessageDigest hash;
		if (hashFunction == null)
			hashFunction = DEFAULT_HASH_FUNCTION;
		
		this.KEY_PARAMETERS_HASH_FUNCTION = hashFunction;
		hash = MessageDigest.getInstance(this.KEY_PARAMETERS_HASH_FUNCTION);
				
		KeyGenerationParameters param = createPQ(modulusSize,keySize,hash,r);
		this.p = param.p;
		this.q = param.q;
		this.DOMAIN_PARAMETER_SEED = param.domain_parameter_seed;
		this.COUNTER = param.counter;
		
		/* the first generator created following A2.3 of FIPS_186-3 */
		BigInteger g = null;
		int index;
		for(index=1; index <= 256; index++)
		{
			try{
				g = getQOrderGenerator(index);
				break;
			}catch(GeneralSecurityException e)
			{
				if(index == 256) //last available index => cannot create a generator
					throw new GeneralSecurityException("No generator could be created.");
			}
		}
		
		this.g = g;
		this.GENERATOR_INDEX = index;
		
	}
	
	
	/**
	 * Randomly creates the key parameters for a given keySize using the algorithm 
	 * A.1.1.2 of FIPS_186-3 (the list of acceptable sizes is not verified)
	 * 
  	 * @param modulusSize defines the length of p (parameter L of A.1.1.2)
	 * @param keySize maximum supported key size in bits (defines the length of q)
	 * 				  (parameter N of A.1.1.2)
	 * @param hash hash function to use in the key parameters generation
	 * @param random randomness source
	 * @return KeyGenerationParameters with the p and q key parameters and the domain_seed and 
	 * counter generation parameters
	 */
	private final KeyGenerationParameters createPQ(int modulusSize, int keySize, MessageDigest hash, Random random)
	{
		
			
		/* some necessary variable declarations */
		BigInteger p, q;
		byte[] domain_parameter_seed;
		BigInteger domain_parameter_seed_BigInt;
		
		 //safety procedure
		hash.reset();
		
		/**** process begin ****/
		//step 1 - list of acceptable values not ckecked
		int N = keySize;
		int L = modulusSize;
				
		//step 2
		int seedlen = N/8 + N%8; //size in bytes
		
		//step 3
		int outlen = hash.getDigestLength()*8; //outlen in bits
			// n = ceil(L/outlen)-1 
		int n = (L/outlen + ((L % outlen != 0) ? 1 : 0))-1;
		
		//step 4
		int b = L - 1 - (n*outlen);
		
		
		while(true)
		{
			do{
				//step 5
				domain_parameter_seed = new byte[seedlen];
				random.nextBytes(domain_parameter_seed);
				domain_parameter_seed_BigInt = new BigInteger(1, domain_parameter_seed);

				//step 6
				BigInteger hashDomainParameterSeed = new BigInteger(1, hash.digest(domain_parameter_seed));
				BigInteger U = hashDomainParameterSeed.mod(TWO.pow(N-1));

				//step 7
				q = TWO.pow(N-1).add(U).add(ONE).subtract(U.mod(TWO));

				//step 8 and 9 
				//128 chosen accordingly to Appendix C of FIPS_186-3			
			}while(!q.isProbablePrime(128));

			//step 10
			int offset = 1;

			//step 11
			for(long counter = 0; counter <= 4*L-1; counter++)
			{
				//step 11.1
				byte[][] V = new byte[n+1][];
				for(int j=0; j<=n; j++)
				{
					BigInteger offsetPlusJ = BigInteger.valueOf(offset+j);
					V[j] = hash.digest((domain_parameter_seed_BigInt.add(offsetPlusJ)).toByteArray());
				}
				
				//step 11.2
				BigInteger W = ZERO;
				for(int j=0; j<n; j++)
				{
					BigInteger Vj = new BigInteger(1,V[j]);
					W = W.add(Vj.multiply(TWO.pow(j*outlen)));
				}
				BigInteger Vn = new BigInteger(1,V[n]);
				W = W.add((Vn.mod(TWO.pow(b))).multiply(TWO.pow(n*outlen)));
				
				//step 11.3
				BigInteger X = W.add(TWO.pow(L-1));
						
				//step 11.4
				BigInteger c = X.mod(TWO.multiply(q));
				
				//step 11.5
				p = X.subtract((c.subtract(ONE))); 
				
				//step 11.6
				if (p.compareTo(TWO.pow(L-1)) >= 0)
				{
					//step 11.7 and 11.8
					if(p.isProbablePrime(128)) //128 chosen accordingly to Appendix C of FIPS_186-3
						return new KeyGenerationParameters(p, q, domain_parameter_seed, counter);
				}
				
				//step 11.9
				offset = offset + n + 1;
			}

		//step 12 - go to step 5
		}
	}
	
	
	/**
	 * Create the requested q-order generator of Z*_p 
	 * following algorithm A2.3 of FIPS_186-3.
	 * 
	 * @param index generator index 
	 * @return returns the requested q-order generator
	 * @throws GeneralSecurityException if the index generator cannot be created
	 * @throws InvalidAlgorithmParameterException if no data on the key parameters 
	 * 													generation is available.
	 */
	public final BigInteger getQOrderGenerator(int index) throws GeneralSecurityException
	{
		if (this.DOMAIN_PARAMETER_SEED == null || this.KEY_PARAMETERS_HASH_FUNCTION == null)
			throw new InvalidAlgorithmParameterException("No key parameters generation data is available.");
	
		MessageDigest hash = MessageDigest.getInstance(this.KEY_PARAMETERS_HASH_FUNCTION);
		hash.reset(); //safety procedure;
		
		BigInteger g;
		
		// pre-filling U
		byte[] ggen = new byte[] {0x67,0x67,0x65,0x6E};
		
		//index length -> +1; count length -> +2
		byte[] U = new byte[this.DOMAIN_PARAMETER_SEED.length + ggen.length + 1 + 2];
		
		//fill U
		int indexU;
		for(indexU = 0; indexU < this.DOMAIN_PARAMETER_SEED.length; indexU++)
			U[indexU] = this.DOMAIN_PARAMETER_SEED[indexU];
		
		for(int indexGgen = 0; indexGgen < ggen.length; indexGgen++, indexU++)
			U[indexU] = ggen[indexGgen];
				
		
		/*** process begin ***/
		//Step 1
		if (index <= 0 || index >= 256) 
			throw new InvalidParameterException("Condition not satisfied:  0 < index must be < 256");
		
		//adding index to the U value (extra optimization step)
		U[indexU] = (byte) index;
		indexU++;
		
		//Step 2
		//N = len(q) ?? N not used in the algorithm??
		
		//Step 3
		BigInteger e = (this.p.subtract(ONE)).divide(this.q);
		
		//Step 4
		int count = 0; //16-bit integer but using a 32 bits integer type (int)
		
		//Step 5
		do {
			count++;
			
			//Step 6
			//count == 2^16 = 65536 means the wrap around in a 16-bit counter
			if (count == 65536) throw new GeneralSecurityException("INVALID generator index: counter wrap around");
			
			//Step 7
			U[U.length-2] = (byte) (count >> 8);
			U[U.length-1] = (byte) count;
			
			//Step 8
			BigInteger W = new BigInteger(1, hash.digest(U));
			
			//Step 9
			g = W.modPow(e, this.p); 
			
		//Step 10
		} while(g.compareTo(TWO) < 0);
		
		//Step 11
		return g;
	}
		
	
	
	public final String toString(int radix)
	{
		String s = "p = " + this.p.toString(radix) + "\n"
				 + "q = " + this.q.toString(radix) + "\n"
				 + "g = " + this.g.toString(radix);
		return s;
	}
	
	public final String toString()
	{
		return toString(ElGamalKeyParameters.TO_STRING_RADIX);
	}
	
	
}
