package gsd.inescid.crypto;

import gsd.inescid.math.algebra.matrix.MatrixUtil;

import java.math.BigInteger;
import java.security.GeneralSecurityException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidParameterException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Random;

/**
 * Immutable class ElGamalKeyParameters
 * This class implements the ElGamal parameters generation based on an
 * adaptation of the DSA key generation algorithms defined in FIPS_186-3, 
 * algorithms A.1.1.2 (for p and q) and A.2.3 (for the generator))
 * 
 * The adaptation consists in choosing q such that q = 1 mod 4 and knowing i such that q-1 = i^2.
 * 
 * @author Rui Joaquim
 *
 */
public final class MP2ElGamalKeyParameters {

	public static final int MINIMUM_KEY_SIZE = 5;
	public static final int TO_STRING_RADIX = 10;
	public static final String DEFAULT_HASH_FUNCTION = "SHA-256";
	
	public static final BigInteger TWO = new BigInteger("2"); //public because it is not available in the BigInteger class
	public static final BigInteger FOUR = new BigInteger("4"); //public because it is not available in the BigInteger class
	private static final BigInteger ONE = BigInteger.ONE;
	private static final BigInteger ZERO = BigInteger.ZERO;
	

	/** a prime that defines the "encryption group" Z*_p, such that p = 2kq + 1 */
	public final BigInteger p; 
	/** base prime number */
	public final BigInteger q;
	/** generator of G_q, a q-order subgroup of Z*_p that defines the message space */
	public final BigInteger g; 
	
	/** i such that i^2 = q-1 */
	public final BigInteger i; 

	/** SO(2,q) generator */
	public final BigInteger [][] SO2qGenerator;
	
	/** SO2qOrder = q-1 **/
	public final BigInteger SO2qOrder; 
	
	/** FOUR_MULT_FACTOR * 4 = SO2qOrder/lambda **/
	public final BigInteger FOUR_MULT_FACTOR; 
	
	/** lambda = SO2qOrder/(4 * FOUR_MULT_FACTOR) **/
	public final BigInteger lambda; 
	
	/**
	 * The generator index following the 
	 * generator creation algorithm A2.3 of FIPS_186-3.
	 */
	public final int GENERATOR_INDEX;
	
	/** As defined in algorithm A.1.1.2 of FIPS_186-3.
	 *  The value is null if the key parameters were not 
	 *  generated by this instance of ElGamalKeyParameters. */
	public final byte[] DOMAIN_PARAMETER_SEED;
	
	/** As defined in algorithm A.1.1.2 of FIPS_186-3.
	 *  The value is -1 if the key parameters were not 
	 *  generated by this instance of ElGamalKeyParameters. */
	public final long COUNTER;
	
	/**
	 * The hash function used in the creation of the key parameters.
	 */
	public final String KEY_PARAMETERS_HASH_FUNCTION;
	
		
	
	/**
	 * Class created to temporary contain the results of the KeyGenerationProcess
	 */
	private final class KeyGenerationParameters{
		BigInteger p;
		BigInteger q;
		BigInteger i;
		byte[] domain_parameter_seed;
		long counter;
		
		KeyGenerationParameters(BigInteger p, BigInteger q, BigInteger i, byte[] seed, long counter)
		{
			this.p = p;
			this.q = q;
			this.i = i;
			this.domain_parameter_seed = seed;
			this.counter = counter;
		}
	}
		

	
	/**
	 * Create key parameters for the requested key size.
	 * The key parameter are created following an adaptation of algorithm A.1.1.2 of FIPS_186-3 
	 * (the list of acceptable sizes is not verified).
	 * The generator is created following algorithm A2.3 of FIPS_186-3 using 
	 * the first available index.
	 * 
	 * @param modulusSize defines the length of p in bits
	 * @param keySize maximum supported key size in bits (defines the length of q)
	 * @param lambdaSize the size of parameter lambda in bits. 
	 * @param random randomness source. If null an instance of the default SecureRandom is used.
	 * @param hashFunction the hash function to use in the key generation process. 
	 * 			   If null the default hash function (SHA-256) will be used. 
	 * @throws GeneralSecurityException if no generator or lambda could be created.
	 * @throws InvalidParameterException if keySize < MINIMUM_KEY_SIZE, modulusSize <= keySize or lambdaSize > keySize-2.
	 * @throws NoSuchAlgorithmException if there is no provider for the selected hashFunction
	 */
	public MP2ElGamalKeyParameters(int modulusSize, int keySize, int lambdaSize, Random r, String hashFunction) throws GeneralSecurityException
	{
		if (keySize < MINIMUM_KEY_SIZE) throw new InvalidParameterException("keySize must be >= MINIMUM_KEY_SIZE");
		if (modulusSize <= keySize) throw new InvalidParameterException("modulusSize must be > key_size");
		if (lambdaSize > keySize-2) throw new InvalidParameterException("lambdaSize must be <= key_size - 2");
		
		if (r == null)
			r = new SecureRandom();
		
		MessageDigest hash;
		if (hashFunction == null)
			hashFunction = DEFAULT_HASH_FUNCTION;
		
		this.KEY_PARAMETERS_HASH_FUNCTION = hashFunction;
		hash = MessageDigest.getInstance(this.KEY_PARAMETERS_HASH_FUNCTION);
				
		KeyGenerationParameters param = createPQ(modulusSize,keySize,hash,r);
		this.p = param.p;
		this.q = param.q;
		this.i = param.i;
		this.DOMAIN_PARAMETER_SEED = param.domain_parameter_seed;
		this.COUNTER = param.counter;
		
		/* the first generator created following A2.3 of FIPS_186-3 */
		BigInteger g = null;
		int index;
		for(index=1; index <= 256; index++)
		{
			try{
				g = getQOrderGenerator(index);
				break;
			}catch(GeneralSecurityException e)
			{
				if(index == 256) //last available index => cannot create a generator
					throw new GeneralSecurityException("No generator could be created.");
			}
		}
		
		this.g = g;
		this.GENERATOR_INDEX = index;
		this.SO2qGenerator = getSO2qGenerator();
		this.SO2qOrder = this.q.subtract(ONE);
		// Compute the correct lambda
		// The initial lambda is the SO2QOrder divided by four
		BigInteger tempLambda = this.SO2qOrder.divide(new BigInteger("4"));
		/* the final lambda is the initial lambda divided by a multiply of four, 
		   such that the final lambda is in the desired bit length
		*/ 
		BigInteger[] aux = lambdaDivisor(tempLambda, lambdaSize);
		this.lambda = aux[1];
		this.FOUR_MULT_FACTOR = aux[0];
	}
	
	
	private BigInteger[] lambdaDivisor(BigInteger lambda, int lambdaSize) throws GeneralSecurityException
	{
		BigInteger divisor = TWO.pow(lambdaSize);
		BigInteger[] result;
		do{
			divisor = divisor.subtract(BigInteger.ONE);
			result = lambda.divideAndRemainder(divisor);
			if(divisor.bitLength() < lambdaSize)
				throw new GeneralSecurityException("cannot create lambda.");
		}while (!result[1].equals(BigInteger.ZERO));
		result[1] = divisor;
		return result;
	}
	
	
	/**
	 * Obtains SO(2,q) generator from the q-order generator. 
	 */
	
	private BigInteger[][] getSO2qGenerator()
	{
		BigInteger twoInvModQ = TWO.modInverse(this.q);
		BigInteger minusI = this.q.subtract(this.i);
		
		BigInteger iTimesTwoInvModQ = this.i.multiply(twoInvModQ).mod(this.q);
		BigInteger minusITimesTwoInvModQ = minusI.multiply(twoInvModQ).mod(this.q);
		
		BigInteger[][] A = new BigInteger[][] {{twoInvModQ, iTimesTwoInvModQ},
											   {minusITimesTwoInvModQ, twoInvModQ}};
		
		BigInteger[][] B = new BigInteger[][] {{twoInvModQ, minusITimesTwoInvModQ},
				 							   {iTimesTwoInvModQ, twoInvModQ}};
		
		//test A and B
		System.out.println(this.i.multiply(this.i).mod(this.q));
		System.out.println(BigInteger.ZERO.subtract(ONE).mod(this.q));
		System.out.println(TWO.multiply(twoInvModQ).mod(this.q));
		
		System.out.println("A:\n " + MatrixUtil.toString(A));
		System.out.println("B:\n" + MatrixUtil.toString(B));
		System.out.println("A^2 ?= A:\n" + MatrixUtil.toString(MatrixUtil.matrixMultiplication(A, A, this.q)));
		System.out.println("B^2 ?= B:\n" + MatrixUtil.toString(MatrixUtil.matrixMultiplication(B, B, this.q)));
		System.out.println("AB ?= 0:\n" + MatrixUtil.toString(MatrixUtil.matrixMultiplication(A, B, this.q)));
		//end test
		
		BigInteger gInv = this.g.modInverse(this.q);
		
		BigInteger[][] gA = MatrixUtil.matrixMultiplication(A, this.g, this.q);
		BigInteger[][] gInvB = MatrixUtil.matrixMultiplication(B, gInv, this.q);
		
		BigInteger[][] generatorSO2q = MatrixUtil.matrixAddition(gA, gInvB, this.q);
		
		return generatorSO2q;
	}
	
	
	
	
	
	
	/**
	 * Randomly creates the key parameters for a given keySize using an adaptation of
	 * the algorithm A.1.1.2 of FIPS_186-3.
	 * The adaptation consists in choosing q such that q = 1 mod 4 and knowing i such that q-1 = i^2 
	 * The list of acceptable sizes is not verified.
	 * 
  	 * @param modulusSize defines the length of p (parameter L of A.1.1.2)
	 * @param keySize the maximum supported key size in bits (defines the length of q -> parameter N of A.1.1.2)
	 * @param hash hash function to use in the key parameters generation
	 * @param random randomness source
	 * @return KeyGenerationParameters with the p and q key parameters and the domain_seed and 
	 * counter generation parameters
	 */
	private final KeyGenerationParameters createPQ(int modulusSize, int keySize, MessageDigest hash, Random random)
	{		
		/* some necessary variable declarations */
		BigInteger p, q, I;
		byte[] domain_parameter_seed;
		BigInteger domain_parameter_seed_BigInt;
		
		 //safety procedure
		hash.reset();
		
		/**** process begin ****/
		//step 1 - list of acceptable values not ckecked
		int N = keySize;
		int L = modulusSize;
				
		//step 2
		int seedlen = N/8 + N%8; //size in bytes
		
		//step 3
		int outlen = hash.getDigestLength()*8; //outlen in bits
			// n = ceil(L/outlen)-1 
		int n = (L/outlen + ((L % outlen != 0) ? 1 : 0))-1;
		
		//step 4
		int b = L - 1 - (n*outlen);
		
		
		while(true)
		{
			do{
				//step 5
				domain_parameter_seed = new byte[seedlen];
				random.nextBytes(domain_parameter_seed);
				domain_parameter_seed_BigInt = new BigInteger(1, domain_parameter_seed);

				//step 6 - Adaptation
				BigInteger hashDomainParameterSeed = new BigInteger(1, hash.digest(domain_parameter_seed));
				//BigInteger U = hashDomainParameterSeed.mod(TWO.pow(N-1));
				BigInteger lowLimit;
				BigInteger highLimit;
				
				if(N%2 == 0)//N even => rough approximation to the low limit for the q-1 square root 
				{
					lowLimit = TWO.pow(N/2-1).add(TWO.pow(N/2-2));
					highLimit = TWO.pow(N/2);
					
				} else {//N odd  => rough approximation to the high limit for the q-1 square root
					lowLimit = TWO.pow(N/2);
					highLimit = TWO.pow(N/2).add(TWO.pow(N/2-1));
				}
				
				I = hashDomainParameterSeed.mod(highLimit.subtract(lowLimit));
				
				
				//step 7 - Adaptation
				//q = TWO.pow(N-1).add(U).add(ONE).subtract(U.mod(TWO));
				I = lowLimit.add(I).add(I.mod(TWO));
				q = I.multiply(I).add(ONE);
				
				/*
				System.out.println("-------------------");
				System.out.println(hashDomainParameterSeed);
				System.out.println(I);
				System.out.println(q);
				*/
				
				//step 8 and 9 - Adaptation
				//128 chosen accordingly to Appendix C of FIPS_186-3			
			}while(q.bitLength()!=N || !(q.mod(BigInteger.valueOf(4))).equals(BigInteger.ONE) || !q.isProbablePrime(128));

			//step 10
			int offset = 1;

			//step 11
			for(long counter = 0; counter <= 4*L-1; counter++)
			{
				//step 11.1
				byte[][] V = new byte[n+1][];
				for(int j=0; j<=n; j++)
				{
					BigInteger offsetPlusJ = BigInteger.valueOf(offset+j);
					V[j] = hash.digest((domain_parameter_seed_BigInt.add(offsetPlusJ)).toByteArray());
				}
				
				//step 11.2
				BigInteger W = ZERO;
				for(int j=0; j<n; j++)
				{
					BigInteger Vj = new BigInteger(1,V[j]);
					W = W.add(Vj.multiply(TWO.pow(j*outlen)));
				}
				BigInteger Vn = new BigInteger(1,V[n]);
				W = W.add((Vn.mod(TWO.pow(b))).multiply(TWO.pow(n*outlen)));
				
				//step 11.3
				BigInteger X = W.add(TWO.pow(L-1));
						
				//step 11.4
				BigInteger c = X.mod(TWO.multiply(q));
				
				//step 11.5
				p = X.subtract((c.subtract(ONE))); 
				
				//step 11.6
				if (p.compareTo(TWO.pow(L-1)) >= 0)
				{
					//step 11.7 and 11.8
					if(p.isProbablePrime(128)) //128 chosen accordingly to Appendix C of FIPS_186-3
						return new KeyGenerationParameters(p, q, I, domain_parameter_seed, counter);
				}
				
				//step 11.9
				offset = offset + n + 1;
			}

		//step 12 - go to step 5
		}
	}
	
	
	/**
	 * Create the requested q-order generator of Z*_p 
	 * following algorithm A2.3 of FIPS_186-3.
	 * 
	 * @param index generator index 
	 * @return returns the requested q-order generator
	 * @throws GeneralSecurityException if the index generator cannot be created
	 * @throws InvalidAlgorithmParameterException if no data on the key parameters 
	 * 													generation is available.
	 */
	public final BigInteger getQOrderGenerator(int index) throws GeneralSecurityException
	{
		if (this.DOMAIN_PARAMETER_SEED == null || this.KEY_PARAMETERS_HASH_FUNCTION == null)
			throw new InvalidAlgorithmParameterException("No key parameters generation data is available.");
	
		MessageDigest hash = MessageDigest.getInstance(this.KEY_PARAMETERS_HASH_FUNCTION);
		hash.reset(); //safety procedure;
		
		BigInteger g;
		
		// pre-filling U
		byte[] ggen = new byte[] {0x67,0x67,0x65,0x6E};
		
		//index length -> +1; count length -> +2
		byte[] U = new byte[this.DOMAIN_PARAMETER_SEED.length + ggen.length + 1 + 2];
		
		//fill U
		int indexU;
		for(indexU = 0; indexU < this.DOMAIN_PARAMETER_SEED.length; indexU++)
			U[indexU] = this.DOMAIN_PARAMETER_SEED[indexU];
		
		for(int indexGgen = 0; indexGgen < ggen.length; indexGgen++, indexU++)
			U[indexU] = ggen[indexGgen];
				
		
		/*** process begin ***/
		//Step 1
		if (index <= 0 || index >= 256) 
			throw new InvalidParameterException("Condition not satisfied:  0 < index must be < 256");
		
		//adding index to the U value (extra optimization step)
		U[indexU] = (byte) index;
		indexU++;
		
		//Step 2
		//N = len(q) ?? N not used in the algorithm??
		
		//Step 3
		BigInteger e = (this.p.subtract(ONE)).divide(this.q);
		
		//Step 4
		int count = 0; //16-bit integer but using a 32 bits integer type (int)
		
		//Step 5
		do {
			count++;
			
			//Step 6
			//count == 2^16 = 65536 means the wrap around in a 16-bit counter
			if (count == 65536) throw new GeneralSecurityException("INVALID generator index: counter wrap around");
			
			//Step 7
			U[U.length-2] = (byte) (count >> 8);
			U[U.length-1] = (byte) count;
			
			//Step 8
			BigInteger W = new BigInteger(1, hash.digest(U));
			
			//Step 9
			g = W.modPow(e, this.p); 
			
		//Step 10
		} while(g.compareTo(TWO) < 0);
		
		//Step 11
		return g;
	}
	
	/*TODO comment methods below */
	
	public final ElGamalKeyParameters getElGamalKeyParameters()
	{
		return new ElGamalKeyParameters(this.p, this.q, this.g);
	}
	
	
	public final String toString()
	{
		String s = "p = " + this.p.toString() + "\n"
				 + "q = " + this.q.toString() + "\n"
				 + "g = " + this.g.toString() + "\n"
				 + "SO2qGenerator = \n" + MatrixUtil.toString(this.SO2qGenerator);
		return s;
	}
	
	
	public static MP2ElGamalKeyParameters getInstance(int modulusSize, int keySize, int lambdaSize)
	{
		MP2ElGamalKeyParameters param = null;
		int i=0;
		do
		{
			i++;
			System.out.println("Create MP2 parameters try:" + i + " ...");
			try{
				param = new MP2ElGamalKeyParameters(modulusSize, keySize, lambdaSize, new SecureRandom(), null);
			} catch (GeneralSecurityException e)
			{
				System.out.println("\nFAIL\n");
			}
		} while (param == null);
		System.out.println("\nSUCCESS\n");
		return param;
	}
	
}
